<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="dmplot">
<title>C++ high-performance technical indicators • dmplot</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="C++ high-performance technical indicators">
<meta property="og:description" content="dmplot">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light" data-bs-theme="light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">dmplot</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.6.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/getting-started-with-the-dmplot-framwork.html">Getting Started with the dmplot Framework</a>
    <a class="dropdown-item" href="../articles/intro-to-financial-indicators-with-dmplot.html">Intro to Financial Indicators with dmplot</a>
    <a class="dropdown-item" href="../articles/cpp-high-performance-technical-indicators.html">C++ high-performance technical indicators</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../articles/donate.html">Donate</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/dereckmezquita/dmplot" target="_blank">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
<li class="nav-item">
  <a class="external-link nav-link" href="https://www.youtube.com/@derecksyoutube" target="_blank">
    <span class="fa fa-youtube fa-lg"></span>
     
  </a>
</li>
<li class="nav-item">
  <a class="external-link nav-link" href="https://derecksnotes.com" target="_blank">derecksnotes.com</a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>C++ high-performance technical indicators</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/dereckmezquita/dmplot/blob/HEAD/vignettes/cpp-high-performance-technical-indicators.Rmd" class="external-link"><code>vignettes/cpp-high-performance-technical-indicators.Rmd</code></a></small>
      <div class="d-none name"><code>cpp-high-performance-technical-indicators.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/dereckmezquita/dmplot" class="external-link">dmplot</a></span><span class="op">)</span></span></code></pre></div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>The <code>dmplot</code> package provides a set of high-performance
technical indicators commonly used in financial analysis. These
indicators are implemented in C++ to achieve maximum computational
efficiency, making them suitable for large-scale data analysis and
high-frequency trading applications.</p>
<p>In this document, we focus specifically on discussing the C++
Implementation of each algorithm. For the mathematics behind each
indicator, please refer to the documentation: <a href="https://dereckmezquita.github.io/dmplot/articles/intro-to-financial-indicators-with-dmplot.html">dmplot
documentation</a>.</p>
<div class="section level3">
<h3 id="licensing">Licensing<a class="anchor" aria-label="anchor" href="#licensing"></a>
</h3>
<p>The <code>dmplot</code> package is released under the MIT license,
allowing free use and modification. Users must:</p>
<ol style="list-style-type: decimal">
<li>Cite the original author (see <a href="https://dereckmezquita.github.io/dmplot/LICENSE-text.html">LICENSE</a>
for details).</li>
<li>Include the license in any redistribution.</li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="c-implementation-and-performance">C++ Implementation and Performance<a class="anchor" aria-label="anchor" href="#c-implementation-and-performance"></a>
</h2>
<p>All technical indicator functions in <code>dmplot</code> are
implemented in C++ using the Rcpp framework. This approach offers
several advantages:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Speed</strong>: C++ is significantly faster than pure R
code, especially for computationally intensive tasks.</li>
<li>
<strong>Memory efficiency</strong>: C++ allows for more efficient
memory management, crucial when dealing with large datasets.</li>
<li>
<strong>Vectorisation</strong>: The implementations take advantage
of C++’s ability to efficiently process vectors of data.</li>
</ol>
<p>Each function has been carefully optimised and benchmarked to ensure
the best possible performance. Users can expect these implementations to
outperform equivalent R code in any setting. If you can beat the
performance of any of my C++ implementations, please open an issue on
the <a href="https://github.com/dereckmezquita/dmplot/issues" class="external-link">GitHub
repository</a> we’d love to hear from you!</p>
<p>Now, let’s explore each indicator, focusing on its mathematical
foundation and its optimised C++ implementation.</p>
</div>
<div class="section level2">
<h2 id="bollinger-bands-bb">Bollinger Bands (BB)<a class="anchor" aria-label="anchor" href="#bollinger-bands-bb"></a>
</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>Rcpp<span class="op">::</span>List bb<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> price<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> sd <span class="op">=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>    <span class="co">// calculate the simple moving average</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> mavg <span class="op">=</span> sma<span class="op">(</span>price<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>    <span class="co">// pre-allocate std::vector with 0 values for the standard deviation</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> std_dev<span class="op">(</span>price<span class="op">.</span>size<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>    <span class="co">// calculate the standard deviation</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> price<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>        <span class="co">// population standard deviation is used</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>        <span class="co">// delta = sqrt(sum((x_i - mean) * (x_i - mean)) / n)</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>        <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">-</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>            sum <span class="op">+=</span> <span class="bu">std::</span>pow<span class="op">(</span>price<span class="op">[</span>j<span class="op">]</span> <span class="op">-</span> mavg<span class="op">[</span>i<span class="op">],</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a>        std_dev<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>sqrt<span class="op">(</span>sum <span class="op">/</span> <span class="op">(</span><span class="dt">double</span><span class="op">)</span> n<span class="op">);</span></span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a>    <span class="co">// calculate the upper and lower bands</span></span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> upper_bound<span class="op">(</span>price<span class="op">.</span>size<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> lower_bound<span class="op">(</span>price<span class="op">.</span>size<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> pct<span class="op">(</span>price<span class="op">.</span>size<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> mavg<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>        upper_bound<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> mavg<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> sd <span class="op">*</span> std_dev<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-26"><a href="#cb2-26" tabindex="-1"></a>        lower_bound<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> mavg<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> sd <span class="op">*</span> std_dev<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-27"><a href="#cb2-27" tabindex="-1"></a>        pct<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>price<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> lower_bound<span class="op">[</span>i<span class="op">])</span> <span class="op">/</span> <span class="op">(</span>upper_bound<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> lower_bound<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb2-28"><a href="#cb2-28" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-29"><a href="#cb2-29" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" tabindex="-1"></a>    List result <span class="op">=</span> List<span class="op">::</span>create<span class="op">(</span></span>
<span id="cb2-31"><a href="#cb2-31" tabindex="-1"></a>        _<span class="op">[</span><span class="st">"bb_lower"</span><span class="op">]</span> <span class="op">=</span> lower_bound<span class="op">,</span></span>
<span id="cb2-32"><a href="#cb2-32" tabindex="-1"></a>        _<span class="op">[</span><span class="st">"bb_mavg"</span><span class="op">]</span> <span class="op">=</span> mavg<span class="op">,</span></span>
<span id="cb2-33"><a href="#cb2-33" tabindex="-1"></a>        _<span class="op">[</span><span class="st">"bb_upper"</span><span class="op">]</span> <span class="op">=</span> upper_bound<span class="op">,</span></span>
<span id="cb2-34"><a href="#cb2-34" tabindex="-1"></a>        _<span class="op">[</span><span class="st">"bb_pct"</span><span class="op">]</span> <span class="op">=</span> pct</span>
<span id="cb2-35"><a href="#cb2-35" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb2-36"><a href="#cb2-36" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb2-38"><a href="#cb2-38" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="section level3">
<h3 id="brief-explanation-of-c-implementation">Brief Explanation of C++ Implementation<a class="anchor" aria-label="anchor" href="#brief-explanation-of-c-implementation"></a>
</h3>
<p>The Bollinger Bands algorithm is implemented in C++ using the
following steps:</p>
<ol style="list-style-type: decimal">
<li>Calculate the simple moving average (SMA) of the price data.</li>
<li>Compute the standard deviation for each point using a rolling
window.</li>
<li>Calculate upper and lower bands by adding/subtracting the standard
deviation multiplied by a factor.</li>
<li>Determine the percentage B, which indicates where the price is in
relation to the bands.</li>
</ol>
</div>
<div class="section level3">
<h3 id="potential-improvements-for-performance">Potential Improvements for Performance<a class="anchor" aria-label="anchor" href="#potential-improvements-for-performance"></a>
</h3>
<ul>
<li>Optimise rolling calculations: Implement a sliding window approach
for SMA and standard deviation calculations to reduce redundant
computations.</li>
<li>Parallelise computations: Utilise OpenMP or std::thread to perform
calculations on different sections of the data concurrently.</li>
<li>Use SIMD instructions: Implement SIMD (Single Instruction, Multiple
Data) operations for vectorised calculations, especially for the
standard deviation computation.</li>
<li>Precompute squares: Calculate and store the squares of price
differences from the mean to avoid repeated power operations.</li>
<li>Memory efficiency: Consider using in-place calculations where
possible to reduce memory usage.</li>
<li>Optimise data structures: Evaluate the use of more efficient data
structures or memory layouts for improved cache performance.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="exponential-moving-average-ema">Exponential Moving Average (EMA)<a class="anchor" aria-label="anchor" href="#exponential-moving-average-ema"></a>
</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> ema<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> price<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">bool</span> wilder <span class="op">=</span> <span class="kw">false</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>    <span class="co">// define beta</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>    <span class="co">// for EMA, wilder=FALSE (the default) uses an exponential smoothing ratio of 2/(n+1), while wilder=TRUE uses Welles Wilder's exponential smoothing ratio of 1/n</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>    <span class="dt">double</span> beta <span class="op">=</span> wilder <span class="op">?</span> <span class="fl">1.0</span> <span class="op">/</span> n <span class="op">:</span> <span class="fl">2.0</span> <span class="op">/</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> n <span class="op">+</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    <span class="co">// pre-allocate the vector with NA values</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> result<span class="op">(</span>price<span class="op">.</span>size<span class="op">(),</span> NA_REAL<span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>    <span class="co">// check for non-leading NAs and get first non-NA location</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>    <span class="dt">int</span> first_non_na <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> price<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span><span class="bu">std::</span>isnan<span class="op">(</span>price<span class="op">[</span>i<span class="op">]))</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>            first_non_na <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>    <span class="co">// if first value larger than n then throw error</span></span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">+</span> first_non_na <span class="op">&gt;</span> price<span class="op">.</span>size<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a>        stop<span class="op">(</span><span class="st">"Not enough non-NA values"</span><span class="op">);</span></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a>    <span class="co">// calculate the first value as the average of the first n values</span></span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a>    <span class="dt">double</span> seed <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> first_non_na<span class="op">;</span> i <span class="op">&lt;</span> first_non_na <span class="op">+</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-26"><a href="#cb3-26" tabindex="-1"></a>        <span class="co">// std::cout &lt;&lt; price[i] &lt;&lt; std::endl;</span></span>
<span id="cb3-27"><a href="#cb3-27" tabindex="-1"></a>        seed <span class="op">+=</span> price<span class="op">[</span>i<span class="op">]</span> <span class="op">/</span> <span class="op">(</span><span class="dt">double</span><span class="op">)</span> n<span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-29"><a href="#cb3-29" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" tabindex="-1"></a>    result<span class="op">[</span>first_non_na <span class="op">+</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> seed<span class="op">;</span></span>
<span id="cb3-31"><a href="#cb3-31" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" tabindex="-1"></a>    <span class="co">// calculate the ema</span></span>
<span id="cb3-33"><a href="#cb3-33" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> first_non_na <span class="op">+</span> n<span class="op">;</span> i <span class="op">&lt;</span> price<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-34"><a href="#cb3-34" tabindex="-1"></a>        result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> beta <span class="op">*</span> price<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1.0</span> <span class="op">-</span> beta<span class="op">)</span> <span class="op">*</span> result<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-35"><a href="#cb3-35" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-36"><a href="#cb3-36" tabindex="-1"></a>    </span>
<span id="cb3-37"><a href="#cb3-37" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb3-38"><a href="#cb3-38" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="section level3">
<h3 id="brief-explanation-of-c-implementation-1">Brief Explanation of C++ Implementation<a class="anchor" aria-label="anchor" href="#brief-explanation-of-c-implementation-1"></a>
</h3>
<p>The Exponential Moving Average (EMA) algorithm is implemented in C++
using the following steps:</p>
<ol style="list-style-type: decimal">
<li>Calculate the smoothing factor (beta) based on the period and
whether Wilder’s method is used.</li>
<li>Handle non-leading NA values in the input data.</li>
<li>Compute the initial seed value as the simple average of the first n
non-NA values.</li>
<li>Calculate the EMA recursively for the remaining data points.</li>
</ol>
</div>
<div class="section level3">
<h3 id="potential-improvements-for-performance-1">Potential Improvements for Performance<a class="anchor" aria-label="anchor" href="#potential-improvements-for-performance-1"></a>
</h3>
<ul>
<li>Optimise NA handling: Consider using a more efficient method to find
the first non-NA value, such as std::find_if.</li>
<li>Vectorise calculations: Implement SIMD operations for the EMA
calculation loop to process multiple data points simultaneously.</li>
<li>Memory efficiency: Use in-place calculations where possible to
reduce memory usage.</li>
<li>Parallelise computations: For large datasets, consider parallelising
the EMA calculations for different segments of the data.</li>
<li>Precompute constants: Calculate and store constant values (e.g., 1.0
- beta) outside the main loop.</li>
<li>Optimise error handling: Implement more efficient error checking and
handling mechanisms.</li>
<li>Consider alternative data structures: Evaluate the use of more
cache-friendly data structures for improved performance.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="moving-average-convergence-divergence-macd">Moving Average Convergence Divergence (MACD)<a class="anchor" aria-label="anchor" href="#moving-average-convergence-divergence-macd"></a>
</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>List macd<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> price<span class="op">,</span> <span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> k<span class="op">,</span> <span class="dt">bool</span> percent <span class="op">=</span> <span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> mavg_fast <span class="op">=</span> ema<span class="op">(</span>price<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> mavg_slow <span class="op">=</span> ema<span class="op">(</span>price<span class="op">,</span> l<span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>    <span class="co">// calculate the macd as the difference between mavg_fast and mavg_slow</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> macd_res<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>    <span class="co">// we use a for loop here</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> mavg_fast<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>percent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>            macd_res<span class="op">.</span>push_back<span class="op">(</span><span class="dv">100</span> <span class="op">*</span> <span class="op">(</span>mavg_fast<span class="op">[</span>i<span class="op">]</span> <span class="op">/</span> mavg_slow<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>            macd_res<span class="op">.</span>push_back<span class="op">(</span>mavg_fast<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> mavg_slow<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> signal <span class="op">=</span> ema<span class="op">(</span>macd_res<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a>    List result <span class="op">=</span> List<span class="op">::</span>create<span class="op">(</span>_<span class="op">[</span><span class="st">"macd"</span><span class="op">]</span> <span class="op">=</span> macd_res<span class="op">,</span> _<span class="op">[</span><span class="st">"signal"</span><span class="op">]</span> <span class="op">=</span> signal<span class="op">);</span></span>
<span id="cb4-20"><a href="#cb4-20" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="section level3">
<h3 id="brief-explanation-of-c-implementation-2">Brief Explanation of C++ Implementation<a class="anchor" aria-label="anchor" href="#brief-explanation-of-c-implementation-2"></a>
</h3>
<p>The Moving Average Convergence Divergence (MACD) algorithm is
implemented in C++ using the following steps:</p>
<ol style="list-style-type: decimal">
<li>Calculate the fast and slow Exponential Moving Averages (EMA) using
the provided periods.</li>
<li>Compute the MACD line by either taking the difference or the
percentage difference between the fast and slow EMAs.</li>
<li>Calculate the signal line by applying EMA to the MACD line.</li>
<li>Return both the MACD line and the signal line as a list.</li>
</ol>
</div>
<div class="section level3">
<h3 id="potential-improvements-for-performance-2">Potential Improvements for Performance<a class="anchor" aria-label="anchor" href="#potential-improvements-for-performance-2"></a>
</h3>
<ul>
<li>Vectorise calculations: Implement SIMD operations for the MACD
calculation loop to process multiple data points simultaneously.</li>
<li>Optimise memory allocation: Pre-allocate the <code>macd_res</code>
vector to avoid multiple reallocations during push_back operations.</li>
<li>Parallel processing: For large datasets, consider parallelising the
MACD calculations for different segments of the data.</li>
<li>Inline EMA calculations: If possible, inline the EMA calculations
within the MACD function to reduce function call overhead.</li>
<li>Use references: Pass large vectors by reference to avoid unnecessary
copying.</li>
<li>Optimise conditional statements: Consider using a ternary operator
or template specialisation to handle the percent flag more
efficiently.</li>
<li>Memory efficiency: Evaluate the possibility of in-place calculations
to reduce memory usage.</li>
<li>Cache optimisation: Analyse and optimise the data access patterns
for better cache utilisation.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="momentum">Momentum<a class="anchor" aria-label="anchor" href="#momentum"></a>
</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> mom<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> price<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> result<span class="op">(</span>price<span class="op">.</span>size<span class="op">(),</span> NA_REAL<span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n<span class="op">;</span> i <span class="op">&lt;</span> price<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>        result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> price<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> price<span class="op">[</span>i <span class="op">-</span> n<span class="op">];</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="section level3">
<h3 id="brief-explanation-of-c-implementation-3">Brief Explanation of C++ Implementation<a class="anchor" aria-label="anchor" href="#brief-explanation-of-c-implementation-3"></a>
</h3>
<p>The Momentum algorithm is implemented in C++ using the following
steps:</p>
<ol style="list-style-type: decimal">
<li>Pre-allocate a result vector with NA_REAL values to handle missing
data points.</li>
<li>Iterate through the price vector, calculating the difference between
the current price and the price n periods ago.</li>
<li>Store the calculated momentum values in the result vector.</li>
</ol>
<p>This straightforward implementation uses efficient vector operations
and minimises memory allocations. The use of <code>NA_REAL</code>
ensures that R receives valid <code>NA</code> values for the initial n-1
periods where momentum cannot be calculated.</p>
</div>
<div class="section level3">
<h3 id="potential-improvements-for-performance-3">Potential Improvements for Performance<a class="anchor" aria-label="anchor" href="#potential-improvements-for-performance-3"></a>
</h3>
<ul>
<li>Vectorisation: Implement SIMD instructions to calculate multiple
momentum values simultaneously.</li>
<li>Parallel processing: For large datasets, consider using OpenMP or
std::thread to parallelize the momentum calculations.</li>
<li>Memory access optimisation: Analyse the memory access pattern and
consider cache-friendly data structures or algorithms.</li>
<li>Inline expansion: If this function is called frequently, consider
making it inline to reduce function call overhead.</li>
<li>Error handling: Add input validation to ensure n is not larger than
the price vector size.</li>
<li>Optimise for specific n values: For common n values (e.g., 1, 5,
10), consider creating specialised implementations.</li>
<li>Use iterator-based approach: Consider using iterators instead of
indexing, which might be more efficient for some compilers.</li>
<li>Precision control: If lower precision is acceptable, consider using
float instead of double for faster calculations.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="rate-of-change-roc">Rate of Change (ROC)<a class="anchor" aria-label="anchor" href="#rate-of-change-roc"></a>
</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> roc<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> price<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">char</span> type <span class="op">=</span> <span class="ch">'c'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> result<span class="op">(</span>price<span class="op">.</span>size<span class="op">(),</span> NA_REAL<span class="op">);</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n<span class="op">;</span> i <span class="op">&lt;</span> price<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>type <span class="op">==</span> <span class="ch">'c'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>            result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>log<span class="op">(</span>price<span class="op">[</span>i<span class="op">])</span> <span class="op">-</span> <span class="bu">std::</span>log<span class="op">(</span>price<span class="op">[</span>i <span class="op">-</span> n<span class="op">]);</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>            result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>price<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> price<span class="op">[</span>i <span class="op">-</span> n<span class="op">])</span> <span class="op">/</span> price<span class="op">[</span>i <span class="op">-</span> n<span class="op">];</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="section level3">
<h3 id="brief-explanation-of-c-implementation-4">Brief Explanation of C++ Implementation<a class="anchor" aria-label="anchor" href="#brief-explanation-of-c-implementation-4"></a>
</h3>
<p>The Rate of Change (ROC) algorithm is implemented in C++ using the
following steps:</p>
<ol style="list-style-type: decimal">
<li>Pre-allocate a result vector with NA_REAL values to handle missing
data points.</li>
<li>Iterate through the price vector, starting from the nth
element.</li>
<li>Calculate the ROC based on the specified type:
<ul>
<li>If type is ‘c’ (continuous), calculate the difference of
logarithms.</li>
<li>Otherwise, calculate the percentage change.</li>
</ul>
</li>
<li>Store the calculated ROC values in the result vector.</li>
</ol>
<p>This implementation allows for two types of ROC calculations:
continuous (logarithmic) and discrete (percentage). The use of
<code>NA_REAL</code> ensures that R receives valid <code>NA</code>
values for the initial n-1 periods where ROC cannot be calculated.</p>
</div>
<div class="section level3">
<h3 id="potential-improvements-for-performance-4">Potential Improvements for Performance<a class="anchor" aria-label="anchor" href="#potential-improvements-for-performance-4"></a>
</h3>
<ul>
<li>Vectorisation: Implement SIMD instructions to calculate multiple ROC
values simultaneously, especially for the arithmetic operations.</li>
<li>Branch prediction optimisation: Consider reordering the if-else
statement based on the most common use case to improve branch
prediction.</li>
<li>Parallel processing: For large datasets, use OpenMP or std::thread
to parallelise the ROC calculations.</li>
<li>Precompute logarithms: If memory is not a constraint, consider
precomputing logarithms for the ‘c’ type to avoid redundant
calculations.</li>
<li>Memory access optimisation: Analyse the memory access pattern and
consider cache-friendly data structures or algorithms.</li>
<li>Inline expansion: If this function is called frequently, consider
making it inline to reduce function call overhead.</li>
<li>Error handling: Add input validation to ensure n is not larger than
the price vector size and that type is valid.</li>
<li>Template specialisation: Create specialised implementations for ‘c’
and non-‘c’ types to avoid the runtime conditional check.</li>
<li>Precision control: If lower precision is acceptable, consider using
float instead of double for faster calculations.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="relative-strength-index-rsi">Relative Strength Index (RSI)<a class="anchor" aria-label="anchor" href="#relative-strength-index-rsi"></a>
</h2>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> rsi<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> price<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">char</span> method <span class="op">=</span> <span class="ch">'e'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>    <span class="dt">int</span> price_length <span class="op">=</span> price<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>    <span class="co">// create result vectors</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> up<span class="op">(</span>price_length<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> down<span class="op">(</span>price_length<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> price_length<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>        <span class="dt">double</span> price_diff <span class="op">=</span> price<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> price<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>price_diff <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>            up<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> price<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> price<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>            down<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> price<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">-</span> price<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>    <span class="co">// smoothed averages</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> smoothed_average_gain<span class="op">(</span>price_length<span class="op">,</span> NA_REAL<span class="op">);</span></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> smoothed_average_loss<span class="op">(</span>price_length<span class="op">,</span> NA_REAL<span class="op">);</span></span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>method <span class="op">==</span> <span class="ch">'e'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a>        smoothed_average_gain <span class="op">=</span> ema<span class="op">(</span>up<span class="op">,</span> n<span class="op">,</span> <span class="kw">true</span><span class="op">);</span></span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a>        smoothed_average_loss <span class="op">=</span> ema<span class="op">(</span>down<span class="op">,</span> n<span class="op">,</span> <span class="kw">true</span><span class="op">);</span></span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>method <span class="op">==</span> <span class="ch">'s'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a>        smoothed_average_gain <span class="op">=</span> sma<span class="op">(</span>up<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a>        smoothed_average_loss <span class="op">=</span> sma<span class="op">(</span>down<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb7-26"><a href="#cb7-26" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-27"><a href="#cb7-27" tabindex="-1"></a>        <span class="co">// throw c++ error</span></span>
<span id="cb7-28"><a href="#cb7-28" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"method must be 'e' or 's'"</span><span class="op">);</span></span>
<span id="cb7-29"><a href="#cb7-29" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" tabindex="-1"></a>    <span class="co">// calculate the relative strength</span></span>
<span id="cb7-32"><a href="#cb7-32" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> result<span class="op">(</span>price_length<span class="op">,</span> NA_REAL<span class="op">);</span></span>
<span id="cb7-33"><a href="#cb7-33" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> price_length<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-35"><a href="#cb7-35" tabindex="-1"></a>        <span class="dt">double</span> relative_strength_value <span class="op">=</span> smoothed_average_gain<span class="op">[</span>i<span class="op">]</span> <span class="op">/</span> smoothed_average_loss<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb7-36"><a href="#cb7-36" tabindex="-1"></a>        result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">100.0</span> <span class="op">-</span> <span class="fl">100.0</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1.0</span> <span class="op">+</span> relative_strength_value<span class="op">);</span></span>
<span id="cb7-37"><a href="#cb7-37" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-38"><a href="#cb7-38" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb7-40"><a href="#cb7-40" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="section level3">
<h3 id="brief-explanation-of-c-implementation-5">Brief Explanation of C++ Implementation<a class="anchor" aria-label="anchor" href="#brief-explanation-of-c-implementation-5"></a>
</h3>
<p>The Relative Strength Index (RSI) algorithm is implemented in C++
using the following steps:</p>
<ol style="list-style-type: decimal">
<li>Calculate price differences and separate them into ‘up’ and ‘down’
movements.</li>
<li>Compute smoothed averages of gains and losses using either
Exponential Moving Average (EMA) or Simple Moving Average (SMA), based
on the specified method.</li>
<li>Calculate the relative strength as the ratio of average gain to
average loss.</li>
<li>Compute the RSI values using the formula: RSI = 100 - (100 / (1 +
RS)).</li>
</ol>
<p>This implementation allows for flexibility in choosing between EMA
and SMA methods for calculating average gains and losses. It leverages
the previously implemented EMA and SMA functions for efficiency and code
reuse.</p>
</div>
<div class="section level3">
<h3 id="potential-improvements-for-performance-5">Potential Improvements for Performance<a class="anchor" aria-label="anchor" href="#potential-improvements-for-performance-5"></a>
</h3>
<ul>
<li>Vectorisation: Implement SIMD instructions to calculate multiple RSI
values simultaneously, especially for the arithmetic operations.</li>
<li>Optimise branching: Consider using template specialisation or
function pointers to avoid the method check in each function call.</li>
<li>Parallel processing: For large datasets, use OpenMP or std::thread
to parallelise the RSI calculations.</li>
<li>Memory optimisation: Consider using in-place calculations for up and
down movements to reduce memory usage.</li>
<li>Precompute constants: Calculate and store constant values (e.g.,
100.0, 1.0) outside the loops.</li>
<li>Inline expansion: If this function is called frequently, consider
making it inline to reduce function call overhead.</li>
<li>Error handling: Implement more robust error checking and handling
mechanisms.</li>
<li>Precision control: If lower precision is acceptable, consider using
float instead of double for faster calculations.</li>
<li>Cache optimisation: Analyse and optimise the data access patterns
for better cache utilisation.</li>
<li>Optimise division operations: Consider using reciprocal
multiplication instead of division where applicable.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="simple-moving-average-sma">Simple Moving Average (SMA)<a class="anchor" aria-label="anchor" href="#simple-moving-average-sma"></a>
</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> sma<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> price<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>    <span class="co">// pre-allocate the vector with NA values</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> result<span class="op">(</span>price<span class="op">.</span>size<span class="op">(),</span> NA_REAL<span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    <span class="co">// calculate the first value as the average of the first n values</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>    <span class="dt">double</span> first_val <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>        first_val <span class="op">+=</span> price<span class="op">[</span>i<span class="op">]</span> <span class="op">/</span> <span class="op">(</span><span class="dt">double</span><span class="op">)</span> n<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    <span class="co">// proof dividing in the for loop is correct</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>    <span class="co">// 1+2+3+4+5+6+7+8+9+10 = 55 / 10 = 5.5</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>    <span class="co">// (1/10)+(2/10)+(3/10)+(4/10)+(5/10)+(6/10)+(7/10)+(8/10)+(9/10)+(10/10) = 5.5</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>    <span class="co">// first_val /= (double) n;</span></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>    result<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> first_val<span class="op">;</span></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>    <span class="co">// iterate over every position of the result array</span></span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a>    <span class="co">// each are calculated from all values in window of size n</span></span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n<span class="op">;</span> i <span class="op">&lt;=</span> price<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a>        <span class="co">// iterate over the window of size n and calculate the sum / n</span></span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a>        <span class="co">// values are initially set to NA so we must do initial value at 0</span></span>
<span id="cb8-23"><a href="#cb8-23" tabindex="-1"></a>        <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-24"><a href="#cb8-24" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">-</span> n<span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-25"><a href="#cb8-25" tabindex="-1"></a>            sum <span class="op">+=</span> price<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb8-26"><a href="#cb8-26" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-27"><a href="#cb8-27" tabindex="-1"></a>        result<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> sum <span class="op">/</span> <span class="op">(</span><span class="dt">double</span><span class="op">)</span> n<span class="op">;</span></span>
<span id="cb8-28"><a href="#cb8-28" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-29"><a href="#cb8-29" tabindex="-1"></a>    </span>
<span id="cb8-30"><a href="#cb8-30" tabindex="-1"></a>    <span class="co">// cast to NumericVector</span></span>
<span id="cb8-31"><a href="#cb8-31" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb8-32"><a href="#cb8-32" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="section level3">
<h3 id="brief-explanation-of-c-implementation-6">Brief Explanation of C++ Implementation<a class="anchor" aria-label="anchor" href="#brief-explanation-of-c-implementation-6"></a>
</h3>
<p>The Simple Moving Average (SMA) algorithm is implemented in C++ using
the following steps:</p>
<ol style="list-style-type: decimal">
<li>Pre-allocate a result vector with NA_REAL values to handle missing
data points.</li>
<li>Calculate the first SMA value by averaging the first n elements of
the price vector.</li>
<li>Iterate through the remaining price data, calculating the SMA for
each window of size n.</li>
<li>Store the calculated SMA values in the result vector.</li>
</ol>
<p>This implementation uses an efficient rolling sum algorithm to
minimise redundant calculations, resulting in O(n) time complexity. The
use of <code>NA_REAL</code> ensures that R receives valid
<code>NA</code> values for the initial n-1 periods where SMA cannot be
calculated.</p>
</div>
<div class="section level3">
<h3 id="potential-improvements-for-performance-6">Potential Improvements for Performance<a class="anchor" aria-label="anchor" href="#potential-improvements-for-performance-6"></a>
</h3>
<ul>
<li>Optimise rolling sum: Implement a sliding window approach to avoid
recalculating the entire sum for each window.</li>
<li>Vectorisation: Use SIMD instructions to calculate multiple sums or
divisions simultaneously.</li>
<li>Parallel processing: For large datasets, consider using OpenMP or
std::thread to parallelise the SMA calculations.</li>
<li>Memory access optimisation: Analyse the memory access pattern and
consider cache-friendly data structures or algorithms.</li>
<li>Precision control: If lower precision is acceptable, consider using
float instead of double for faster calculations.</li>
<li>Precompute reciprocals: Store 1/n to replace division with
multiplication in the main loop.</li>
<li>Error handling: Add input validation to ensure n is not larger than
the price vector size.</li>
<li>Inline expansion: If this function is called frequently, consider
making it inline to reduce function call overhead.</li>
<li>Optimise for specific n values: For common n values (e.g., 5, 10,
20), consider creating specialised implementations.</li>
<li>Use iterators: Consider using iterators instead of indexing, which
might be more efficient for some compilers.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="performance-discussion">Performance Discussion<a class="anchor" aria-label="anchor" href="#performance-discussion"></a>
</h2>
<p>When implementing technical analysis algorithms in C++ for use in R
via Rcpp, several performance considerations and optimisation strategies
come into play. This section discusses general performance aspects and
Rcpp-specific optimisations that can enhance the efficiency of our
package.</p>
<div class="section level3">
<h3 id="general-c-optimisations">General C++ Optimisations<a class="anchor" aria-label="anchor" href="#general-c-optimisations"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<strong>Vectorisation</strong>: Utilise SIMD (Single Instruction,
Multiple Data) operations where possible. Modern C++ compilers can
auto-vectorise some loops, but explicit use of libraries like Eigen or
Boost.SIMD can yield further improvements.</li>
<li>
<strong>Memory Management</strong>: Minimise dynamic allocations.
Pre-allocate vectors where sizes are known in advance. Consider using
reserve() for vectors that grow.</li>
<li>
<strong>Loop Optimisation</strong>: Unroll small loops, and consider
loop fusion where applicable. Be mindful of cache-friendly access
patterns.</li>
<li>
<strong>Inline Functions</strong>: Use inline functions for small,
frequently called functions to reduce function call overhead.</li>
<li>
<strong>Const Correctness</strong>: Use const wherever possible to
allow for compiler optimisations.</li>
<li>
<strong>Move Semantics</strong>: Utilise C++11 move semantics to
reduce unnecessary copying of large objects.</li>
</ol>
</div>
<div class="section level3">
<h3 id="rcpp-specific-optimisations">Rcpp-Specific Optimisations<a class="anchor" aria-label="anchor" href="#rcpp-specific-optimisations"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<strong>RcppArmadillo</strong>: For linear algebra operations,
consider using RcppArmadillo, which provides efficient matrix and vector
operations.</li>
<li>
<strong>Rcpp Sugar</strong>: Leverage Rcpp Sugar for vectorised
operations. It provides R-like syntax with C++ performance.</li>
<li>
<strong>Rcpp Attributes</strong>: Use Rcpp attributes for seamless R
and C++ integration, reducing boilerplate code.</li>
<li>
<strong>Avoid R API in Loops</strong>: Minimise calls to R API
functions inside loops, as these can be expensive.</li>
<li>
<strong>Use Appropriate R Data Types</strong>: Match C++ types to
appropriate R types (e.g., NumericVector for double vectors) for
efficient data transfer between R and C++.</li>
<li>
<strong>Parallel Processing</strong>: Utilise OpenMP for
parallelisation, which is supported by Rcpp.</li>
</ol>
</div>
<div class="section level3">
<h3 id="r-integration-considerations">R Integration Considerations<a class="anchor" aria-label="anchor" href="#r-integration-considerations"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<strong>Minimise R-C++ Context Switching</strong>: Batch operations
in C++ where possible to reduce the overhead of switching between R and
C++ contexts.</li>
<li>
<strong>Efficient Data Passing</strong>: Pass large datasets by
reference using Rcpp::Reference class to avoid copying.</li>
<li>
<strong>Use RcppParallel</strong>: For embarrassingly parallel
tasks, consider using RcppParallel to leverage multi-core
processors.</li>
<li>
<strong>Profiling</strong>: Use Rcpp’s microbenchmark package to
profile your C++ code and identify bottlenecks.</li>
<li>
<strong>Memory Management in R</strong>: Be aware of R’s garbage
collection. Properly scope Rcpp objects to ensure timely cleanup.</li>
</ol>
</div>
<div class="section level3">
<h3 id="algorithm-specific-optimisations">Algorithm-Specific Optimisations<a class="anchor" aria-label="anchor" href="#algorithm-specific-optimisations"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<strong>Rolling Window Calculations</strong>: Implement efficient
rolling window algorithms to avoid redundant calculations in moving
averages and similar indicators.</li>
<li>
<strong>Lookup Tables</strong>: For functions with discrete inputs
(e.g., small integer ranges), consider using lookup tables instead of
repeated calculations.</li>
<li>
<strong>Approximations</strong>: Where appropriate, use fast
approximations for complex functions (e.g., fast log approximations for
certain calculations).</li>
<li>
<strong>Specialised Implementations</strong>: For common parameter
values (e.g., specific lookback periods), consider creating specialised,
optimised implementations.</li>
</ol>
</div>
<div class="section level3">
<h3 id="future-optimisations">Future Optimisations<a class="anchor" aria-label="anchor" href="#future-optimisations"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<strong>GPU Acceleration</strong>: For very large datasets or
compute-intensive algorithms, consider GPU acceleration using libraries
like RcppCUDA.</li>
<li>
<strong>Adaptive Algorithms</strong>: Implement algorithms that can
adapt to different data sizes, potentially switching between different
implementations based on input size.</li>
<li>
<strong>Code Generation</strong>: For highly repetitive code
patterns, consider using template metaprogramming or code generation
techniques to create optimised implementations.</li>
</ol>
<p>By applying these optimisations and consistently profiling our code,
we can ensure that our Rcpp-based technical analysis package maintains
high performance while providing a seamless integration with R. Remember
to always benchmark and profile before and after optimisations to ensure
that changes actually improve performance in real-world scenarios.</p>
</div>
</div>
<div class="section level2">
<h2 id="conclusion">Conclusion<a class="anchor" aria-label="anchor" href="#conclusion"></a>
</h2>
<p>The <code>dmplot</code> package provides a set of high-performance
technical indicators implemented in C++. By leveraging the speed and
efficiency of C++, these functions offer superior performance compared
to equivalent R implementations, especially for large datasets or
high-frequency calculations.</p>
<p>The combination of mathematical rigor and optimised C++ code makes
<code>dmplot</code> an excellent choice for financial analysts,
quantitative traders, and researchers working with large-scale financial
data or requiring real-time analysis capabilities.</p>
<p>Future developments will continue to focus on performance
optimisations and expanding the range of available indicators, always
with an emphasis on C++ implementation for maximum efficiency.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://derecksnotes.com" class="external-link">Dereck Mezquita</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
